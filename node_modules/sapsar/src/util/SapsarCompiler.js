const{doctype:doctype,head:head,html:html,body:body,meta:meta}=require("sapsar/base"),Log=require("./Log"),SapsarErrorPage=require("./SapsarErrorPage"),{SHIP_TOUCH:SHIP_TOUCH}=require("../formats/SAPSAR_TOUCH"),getComplexLevel=require("./getComplexLevel"),{createUniqueBuild:createUniqueBuild,getBuildProcesses:getBuildProcesses,removeBuild:removeBuild}=require("./ActiveBuild"),fs=require("fs"),path=require("path");let cache={css:{"*":""},js:{"*":"",touch:SHIP_TOUCH},pageCompilers:{},ship:{},head:{"*":" "},touch:{actions:{}},static:{pages:{},useQueries:[],requests:[]},loaders:{},reports:{css:{},js:{}},util:{404:null},plugins:{}},SapsarMiddleware=(req,res)=>!1;async function ImportMiddleware(){try{SapsarMiddleware=(await import("../../../../middleware/middleware.js")).default,Log.compiler("Imported custom middleware!")}catch(e){Log.compiler("Not using custom middleware.")}}let building=!0;function setBuildStatus(status){building=status}function getBuildStatus(){return building}function getProductionStatus(){return!0}function handleHead(page){let content="";if(null!=cache.head[page]&&(content+=cache.head[page]),content+=cache.head["*"],cache.reports.css[page])for(let x=0;x<cache.reports.css[page].length;x++){const component=cache.reports.css[page][x];content+=`<style data-rcss>${cache.css[component]}</style>`}if(cache.reports.js[page])for(let x=0;x<cache.reports.js[page].length;x++){const component=cache.reports.js[page][x];content+=`<script data-rjs>${cache.js[component]}<\/script>`}return content}function SapsarLoader(id,res){cache.loaders[id]?(res.status(200).end(cache.loaders[id]),delete cache.loaders[id]):res.status(404).end("{}")}async function renderPageStruct(page,content,build,static=!1){const render=body(content,{class:"sapsar-dom"});let shipCollections,finalShip="";for(let x in cache.ship){const regex=new RegExp(`${x}="([^"]*)"`,"g");let actual=[];shipCollections=render.match(regex).map((val=>val.replace(`${x}="`,"").replace('"',""))).map((val=>val.split(" ")));for(let y=0;y<shipCollections.length;y++){const element=shipCollections[y];actual=actual.concat(element)}for(let y in cache.ship[x])actual.includes(y)&&(finalShip+=cache.ship[x][y])}const ActiveCSS=getComplexLevel(render,";ActiveCSS;",";/ActiveCSS;");let finalActiveCSS="";for(let x=0;x<ActiveCSS.content.length;x++)cache.css[ActiveCSS.content[x]]&&(finalActiveCSS+=cache.css[ActiveCSS.content[x]]);const ActiveJS=getComplexLevel(ActiveCSS.edited,";ActiveJS;",";/ActiveJS;");let finalActiveJS="";for(let x=0;x<ActiveJS.content.length;x++)cache.js[ActiveJS.content[x]]&&(finalActiveJS+=cache.js[ActiveJS.content[x]]+"\n");const activeHeadData=getComplexLevel(ActiveJS.edited,";ActiveHead;",";/ActiveHead;");let finalActiveHead="";for(let x=0;x<activeHeadData.content.length;x++)finalActiveHead+=activeHeadData.content[x];const loadCSS=getComplexLevel(activeHeadData.edited,";LoadCSS;",";/LoadCSS;");let finalLoadCSS="";for(let x=0;x<loadCSS.content.length;x++)cache.css[loadCSS.content[x]]&&(finalLoadCSS+=cache.css[loadCSS.content[x]]);const loadJS=getComplexLevel(loadCSS.edited,";LoadJS;",";/LoadJS;");let finalLoadJS="";for(let x=0;x<loadJS.content.length;x++)cache.js[loadJS.content[x]]&&(finalLoadJS+=cache.js[loadJS.content[x]]+"\n");let finalRender=loadJS.edited;if(finalShip){const complexShip=getComplexLevel(loadJS.edited,";Ship;",";/Ship;"),method=complexShip.content[0]||"active";switch(method){case"active":finalActiveCSS+=finalShip;break;case"load":finalLoadCSS+=finalShip;break;default:throw new Error(`At Compiler RPS: Invalid shipping method: "${method}". Only "active" and "load" are valid.`)}finalRender=complexShip.edited}const methods=["add"],addingTypes=["acss","ajs","ahead","lcss","ljs"];for(plugin_name in cache.plugins){const pluginFunc=cache.plugins[plugin_name],data=await pluginFunc(finalRender,page,build,{ActiveCSS:finalActiveCSS,ActiveJS:finalActiveJS,ActiveHead:finalActiveHead,LoadCSS:finalLoadCSS,LoadJS:finalLoadJS});for(let x=0;x<data.length;x++)switch(data[x].method){case"add":switch(data[x].data.type){case"acss":finalActiveCSS+=data[x].data.content;break;case"ajs":finalActiveJS+=data[x].data.content;break;case"ahead":finalActiveHead+=data[x].data.content;break;case"lcss":finalLoadCSS+=data[x].data.content;break;case"ljs":finalLoadJS+=data[x].data.content;break;default:throw new Error(`At Compiler RPS: Invalid adding type at plugin "${plugin_name}": "${data[x].data.type}". Only "${addingTypes.join(", ")}" are valid.`)}break;case"replace":switch(data[x].data.type){case"acss":finalActiveCSS=data[x].data.content;break;case"ajs":finalActiveJS=data[x].data.content;break;case"ahead":finalActiveHead=data[x].data.content;break;case"lcss":finalLoadCSS=data[x].data.content;break;case"ljs":finalLoadJS=data[x].data.content;break;default:throw new Error(`At Compiler RPS: Invalid replacing type at plugin "${plugin_name}": "${data[x].data.type}". Only "${addingTypes.join(", ")}" are valid.`)}break;default:throw new Error(`At Compiler RPS: Invalid method at plugin "${plugin_name}": "${data[x].method}". Only "${methods.join(", ")}" are valid.`)}}let loadBundle="";if(finalLoadCSS){let cssBundleName=`${build}.css`;static?cssBundleName=`static/${page}.css`:setTimeout((()=>{cache.loaders[cssBundleName]&&delete cache.loaders[cssBundleName]}),1e4),cache.loaders[cssBundleName]=finalLoadCSS,loadBundle+=`<link rel="stylesheet" data-lcss href="/_sapsar/loader/${build}.css" />`}if(finalLoadJS){let jsBundleName=`${build}.js`;static?jsBundleName=`static/${page}.js`:setTimeout((()=>{cache.loaders[jsBundleName]&&delete cache.loaders[jsBundleName]}),1e4),cache.loaders[jsBundleName]=finalLoadJS,loadBundle+=`<script data-ljs src="/_sapsar/loader/${build}.js"><\/script>`}return finalActiveCSS&&(finalActiveCSS=`<style data-acss>${finalActiveCSS}</style>`),finalActiveJS&&(finalActiveJS=`<script data-ajs>${finalActiveJS}<\/script>`),`\n        ${doctype()}\n        ${html(head(meta({name:"viewport",content:"width=device-width, initial-scale=1.0"}),meta({charset:"UTF-8"}),`<script data-sapsar>const build = {id: "${build}"}<\/script>`,finalActiveHead,handleHead(page),finalActiveCSS,finalActiveJS,loadBundle),finalRender,{lang:"en"})}\n    `}async function SapsarTouch(func,buildId,req,res){if(cache.touch.actions[func]){const data=await cache.touch.actions[func](req.body,req);await res.end(JSON.stringify(data))}else res.end(JSON.stringify({execute:"console.error('Sapsar could not find this Touch Action.')"}))}async function CachePage(page){cache.pageCompilers[page]||(cache.pageCompilers[page]=(await import(`../../../../pages/${page}.js`)).default),cache.head[page]||(cache.head[page]=" ")}async function SapsarCompiler(page,req,res,dynamic=!1){if(0==await SapsarMiddleware(req,res)){const withQuery=req.originalUrl,path=req.path;if(cache.static.pages[path]||cache.static.pages[withQuery])cache.static.pages[withQuery]?res.end(cache.static.pages[withQuery]):res.end(cache.static.pages[path]);else{if(cache.static.requests.includes(page)){let finalContent="";Log.compiler(`Generating STATIC PAGE CACHE for ${page} (SPEC: ${path})...`);const buildId=createUniqueBuild(res),Rendered_Page=await cache.pageCompilers[page](req,buildId,req.params),struct=await renderPageStruct(page,Rendered_Page,buildId,!0);res.write(struct),finalContent+=struct;let activeBuildProcesses=getBuildProcesses(buildId);for(let x=0;x<activeBuildProcesses.length;x++){let processData=activeBuildProcesses[x],processContent=await processData.process(processData.args);res.write(processContent),finalContent+=processContent}return removeBuild(buildId),res.end(),void(cache.static.pages[path]=finalContent)}try{const buildId=createUniqueBuild(res),Rendered_Page=await cache.pageCompilers[page](req,buildId,req.params),struct=await renderPageStruct(page,Rendered_Page,buildId);res.write(struct);let activeBuildProcesses=getBuildProcesses(buildId);for(let x=0;x<activeBuildProcesses.length;x++){let processData=activeBuildProcesses[x];res.write(await processData.process(processData.args))}removeBuild(buildId),res.end()}catch(err){Log.renderError(page,err);const stack=err.stack;res.status(400).end(SapsarErrorPage(`Error while rendering page: ${page}`,err.name,err.message,stack))}}}}async function SapsarUnknownPageHandler(page,req,res){if(cache.pageCompilers["errors/_404"]){const buildId=createUniqueBuild(res),Rendered_Page=await cache.pageCompilers["errors/_404"](req,buildId,req.params),struct=await renderPageStruct(page,Rendered_Page,buildId);res.write(struct);let activeBuildProcesses=getBuildProcesses(buildId);for(let x=0;x<activeBuildProcesses.length;x++){let processData=activeBuildProcesses[x];res.write(await processData.process(processData.args))}removeBuild(buildId),res.end()}else res.status(404).end(SapsarErrorPage(`Page <b>${page}</b> not found`,"Error 404","Page not found","Try re-checking your app's page files, and seeing if the one you're looking for exists, or simply try relaunching your app.\n            \n            Want a custom 404 error page? Create a file called <b>_404.js</b> in a seperate folder called <b>errors</b> inside your <b>pages</b> folder, and export a simple page function with two inputs: <b>data</b> and <b>page</b>.\n            "))}const SAPSAR_CACHE_LOCATION="../../../../sapsar.json";async function exportCache(){building&&await fs.writeFileSync(path.join(__dirname,SAPSAR_CACHE_LOCATION),JSON.stringify(cache))}async function importCache(){cache=JSON.parse(await fs.readFileSync(path.join(__dirname,SAPSAR_CACHE_LOCATION)).toString())}module.exports={SapsarCompiler:SapsarCompiler,SapsarUnknownPageHandler:SapsarUnknownPageHandler,cache:cache,ImportMiddleware:ImportMiddleware,exportCache:exportCache,importCache:importCache,setBuildStatus:setBuildStatus,getBuildStatus:getBuildStatus,getProductionStatus:getProductionStatus,CachePage:CachePage,SapsarLoader:SapsarLoader,SapsarTouch:SapsarTouch,building:building},Log.compiler("Sapsar Compiler loaded and ready for action.");